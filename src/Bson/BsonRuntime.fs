// --------------------------------------------------------------------------------------
// BSON type provider - methods that are called from the generated erased code
// --------------------------------------------------------------------------------------
namespace FSharp.Data.Runtime

open System
open System.ComponentModel
open System.Globalization
open System.IO
open MongoDB.Bson
open FSharp.Data
open FSharp.Data.Runtime
open FSharp.Data.Runtime.StructuralTypes

#nowarn "10001"

/// [omit]
type IBsonDocument =
    abstract BsonValue : BsonValue
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract Path : unit -> string
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract CreateNew : value:BsonValue * pathIncrement:string -> IBsonDocument

/// Underlying representation of types generated by BsonProvider
[<StructuredFormatDisplay("{_Print}")>]
type BsonDocument = 

    private { /// [omit]
              Bson : BsonValue
              /// [omit]
              Path : string }

    interface IBsonDocument with 
        member x.BsonValue = x.Bson
        member x.Path() = x.Path
        member x.CreateNew(value, pathIncrement) =
            BsonDocument.Create(value, x.Path + pathIncrement)

    /// The underlying BsonValue
    member x.BsonValue = x.Bson

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    member x._Print = x.Bson.ToString()

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    override x.ToString() = x._Print

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member Create(value, path) = 
        { Bson = value
          Path = path } :> IBsonDocument

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member Create(reader:TextReader, cultureStr) = 
        use reader = reader
        let text = reader.ReadToEnd()
        let cultureInfo = TextRuntime.GetCulture cultureStr
        MongoDB.Bson.BsonDocument()

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member CreateList(reader:TextReader, cultureStr) = 
        use reader = reader
        let text = reader.ReadToEnd()
        let cultureInfo = TextRuntime.GetCulture cultureStr
        BsonArray()

/// [omit]
type BsonValueOptionAndPath = 
    { BsonOpt : BsonValue option
      Path : string }

/// Static helper methods called from the generated code for working with BSON
type BsonRuntime =

    // --------------------------------------------------------------------------------------
    // bson option -> type

    static member ConvertString(cultureStr, bson) =
        bson |> Option.bind (BsonConversions.AsString (*useNoneForNullOrWhiteSpace*)true (TextRuntime.GetCulture cultureStr))
    
    static member ConvertInteger(cultureStr, bson) =
        bson |> Option.bind (BsonConversions.AsInteger (TextRuntime.GetCulture cultureStr))
    
    static member ConvertInteger64(cultureStr, bson) =
        bson |> Option.bind (BsonConversions.AsInteger64 (TextRuntime.GetCulture cultureStr))

    static member ConvertFloat(cultureStr, missingValuesStr, bson) =
        bson |> Option.bind (BsonConversions.AsFloat (TextRuntime.GetMissingValues missingValuesStr)
                                                                                                 (*useNoneForMissingValues*)true
                                                                                                 (TextRuntime.GetCulture cultureStr))

    static member ConvertBoolean(cultureStr, bson) =
        bson |> Option.bind (BsonConversions.AsBoolean (TextRuntime.GetCulture cultureStr))

    static member ConvertDateTime(cultureStr, bson) =
        bson |> Option.bind (BsonConversions.AsDateTime (TextRuntime.GetCulture cultureStr))

    /// Operation that extracts the value from an option and reports a meaningful error message when the value is not there
    /// If the originalValue is a scalar, for missing strings we return "", and for missing doubles we return NaN
    /// For other types an error is thrown
    static member GetNonOptionalValue<'T>(path:string, opt:option<'T>, originalValue) : 'T = 
        let getTypeName() = 
            let name = typeof<'T>.Name
            if name.StartsWith "int" 
            then "an " + name
            else "a " + name
        match opt, originalValue with 
        | Some value, _ -> value
        | None, _ when typeof<'T> = typeof<string> -> "" |> unbox
        | None, _ when typeof<'T> = typeof<float> -> Double.NaN |> unbox
        | None, None -> failwithf "'%s' is missing" path
        | None, Some x -> failwithf "Expecting %s at '%s', got %s" (getTypeName()) path <| x.ToString()

    /// Converts BSON array to array of target types
    static member ConvertArray<'T>(doc:IBsonDocument, mapping:Func<IBsonDocument,'T>) = 
        match doc.BsonValue.BsonType with         
        | BsonType.Array ->
            let x =
                doc.BsonValue.AsBsonArray.Values
                |> Seq.filter (fun value ->
                    match value.BsonType with
                    | BsonType.Null -> false
                    | _ -> true)
                |> Seq.toArray

            BsonArray x

        | BsonType.Null -> BsonArray()
        | x -> failwithf "Expecting a list at '%s', got %s" (doc.Path()) <| x.ToString()

    /// Get optional bson property
    static member TryGetPropertyUnpacked(doc:IBsonDocument, name) =
        match doc.BsonValue.BsonType with
        | BsonType.Document ->
            let bdoc = doc.BsonValue.AsBsonDocument
            if bdoc.Contains name then
                let value = bdoc.GetValue name
                match value.BsonType with
                | BsonType.Null -> None
                | _ -> Some value
            else None
        | _ -> None

    /// Get optional bson property and wrap it together with path
    static member TryGetPropertyUnpackedWithPath(doc:IBsonDocument, name) =
        { BsonOpt = BsonRuntime.TryGetPropertyUnpacked(doc, name)
          Path = doc.Path() + "/" + name }

    /// Get optional bson property wrapped in bson document
    static member TryGetPropertyPacked(doc:IBsonDocument, name) =
        BsonRuntime.TryGetPropertyUnpacked(doc, name)
        |> Option.map (fun value -> doc.CreateNew(value, "/" + name))

    /// Get bson property and wrap in bson document
    static member GetPropertyPacked(doc:IBsonDocument, name) =
        match BsonRuntime.TryGetPropertyPacked(doc, name) with
        | Some doc -> doc
        | None -> failwithf "Property '%s' not found at '%s': %s" name (doc.Path()) <| doc.BsonValue.ToString()

    /// Get bson property and wrap in bson document, and return null if not found
    static member GetPropertyPackedOrNull(doc:IBsonDocument, name) =
        match BsonRuntime.TryGetPropertyPacked(doc, name) with
        | Some doc -> doc
        | None -> doc.CreateNew(BsonNull.Value, "/" + name)

    /// Get optional bson property and convert to a specified type
    static member ConvertOptionalProperty<'T>(doc:IBsonDocument, name, mapping:Func<IBsonDocument,'T>) =
        BsonRuntime.TryGetPropertyPacked(doc, name)
        |> Option.map mapping.Invoke

    static member private Matches cultureStr tag =
        match tag with
        | InferedTypeTag.Number ->
            let cultureInfo = TextRuntime.GetCulture cultureStr
            fun json -> (BsonConversions.AsFloat [| |] (*useNoneForMissingValues*)true cultureInfo json).IsSome
        | InferedTypeTag.Boolean ->
            BsonConversions.AsBoolean (TextRuntime.GetCulture cultureStr)
            >> Option.isSome
        | InferedTypeTag.String ->
            BsonConversions.AsString (*useNoneForNullOrWhiteSpace*)true (TextRuntime.GetCulture cultureStr)
            >> Option.isSome
        | InferedTypeTag.DateTime ->
            BsonConversions.AsDateTime (TextRuntime.GetCulture cultureStr)
            >> Option.isSome
        | InferedTypeTag.Collection -> fun (value : BsonValue) -> value.BsonType = BsonType.Array
        | InferedTypeTag.Record _ -> fun (value : BsonValue) -> value.BsonType = BsonType.Document

        | InferedTypeTag.Guid ->
            failwith "Guid type not supported"
        | InferedTypeTag.Json ->
            failwith "Json type not supported"
        | InferedTypeTag.Null ->
            failwith "Null type not supported"
        | InferedTypeTag.Heterogeneous ->
            failwith "Heterogeneous type not supported"

    /// Returns all array values that match the specified tag
    static member GetArrayChildrenByTypeTag<'T>(doc:IBsonDocument, cultureStr, tagCode, mapping:Func<IBsonDocument,'T>) =         
        match doc.BsonValue.BsonType with
        | BsonType.Array ->
            doc.BsonValue.AsBsonArray.Values
            |> Seq.filter (BsonRuntime.Matches cultureStr (InferedTypeTag.ParseCode tagCode))
            |> Seq.mapi (fun i value -> doc.CreateNew(value, "[" + (string i) + "]") |> mapping.Invoke)
            |> Seq.toArray
        | BsonType.Null -> [| |]
        | x -> failwithf "Expecting an array at '%s', got %s" (doc.Path()) <| x.ToString()

    /// Returns single or no value from an array matching the specified tag
    static member TryGetArrayChildByTypeTag<'T>(doc, cultureStr, tagCode, mapping:Func<IBsonDocument,'T>) = 
        match BsonRuntime.GetArrayChildrenByTypeTag(doc, cultureStr, tagCode, mapping) with
        | [| child |] -> Some child
        | [| |] -> None
        | _ -> failwithf "Expecting an array with single or no elements at '%s', got %s" (doc.Path()) <| doc.BsonValue.ToString()

    /// Returns a single array children that matches the specified tag
    static member GetArrayChildByTypeTag(doc, cultureStr, tagCode) = 
        match BsonRuntime.GetArrayChildrenByTypeTag(doc, cultureStr, tagCode, Func<_,_>(id)) with
        | [| child |] -> child
        | _ -> failwithf "Expecting an array with single element at '%s', got %s" (doc.Path()) <| doc.BsonValue.ToString()

    static member private ToBsonValue (cultureInfo:CultureInfo) (value:obj) = 
        let inline optionToBson f = function None -> BsonNull.Value :> BsonValue | Some v -> f v
        match value with
        | null -> BsonNull.Value :> BsonValue
        | :? Array                            as v -> BsonArray [| for elem in v -> BsonRuntime.ToBsonValue cultureInfo elem |] :> BsonValue

        | :? string                         as v -> BsonString v :> BsonValue
        | :? DateTime                     as v -> BsonDateTime v :> BsonValue
        | :? int                                as v -> BsonInt32 v :> BsonValue
        | :? int64                            as v -> BsonInt64 v :> BsonValue
        | :? float                            as v -> BsonDouble v :> BsonValue
        | :? bool                             as v -> BsonBoolean v :> BsonValue
        | :? IBsonDocument            as v -> v.BsonValue
        | :? BsonValue                    as v -> v

        | :? option<string>         as v -> optionToBson (fun x -> BsonString x :> BsonValue) v
        | :? option<DateTime>     as v -> optionToBson (fun (x : DateTime) -> BsonDateTime x :> BsonValue) v
        | :? option<int>                as v -> optionToBson (fun x -> BsonInt32 x :> BsonValue) v
        | :? option<int64>            as v -> optionToBson (fun x -> BsonInt64 x :> BsonValue) v
        | :? option<float>            as v -> optionToBson (fun x -> BsonDouble x :> BsonValue) v
        | :? option<bool>             as v -> optionToBson (fun x -> BsonBoolean x :> BsonValue) v
        | :? option<BsonValue>    as v -> optionToBson id v

        | _ -> failwithf "Can't create BsonValue from %A" value

    /// Creates a scalar BsonValue and wraps it in a bson document
    static member CreateValue(value:obj, cultureStr) = 
        let cultureInfo = TextRuntime.GetCulture cultureStr
        let bson = BsonRuntime.ToBsonValue cultureInfo value
        BsonDocument.Create(bson, "")

    // Creates a BsonValue.Record and wraps it in a bson document
    static member CreateRecord(properties, cultureStr) =
        let cultureInfo = TextRuntime.GetCulture cultureStr
        let bson =
            let x =
                properties
                |> Seq.map (fun (k, v:obj) -> BsonElement(k, BsonRuntime.ToBsonValue cultureInfo v))
            MongoDB.Bson.BsonDocument x

        BsonDocument.Create(bson, "")

    /// Creates a scalar BsonValue.Array and wraps it in a bson document
    static member CreateArray(elements:obj[], cultureStr) =
        let cultureInfo = TextRuntime.GetCulture cultureStr
        let bson =
            let x =
                elements
                |> Seq.collect (BsonRuntime.ToBsonValue cultureInfo >> (fun value ->
                    match value.BsonType with
                    | BsonType.Array -> value.AsBsonArray.Values
                    | BsonType.Null -> Seq.empty
                    | _ -> Seq.singleton value))
                |> Seq.toArray

            BsonArray x
        BsonDocument.Create(bson, "")
